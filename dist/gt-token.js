!function webpackUniversalModuleDefinition(e,r){"object"==typeof exports&&"object"==typeof module?module.exports=r():"function"==typeof define&&define.amd?define([],r):"object"==typeof exports?exports.GTToken=r():e.GTToken=r()}(this,(()=>(()=>{var e={401:()=>{}},r={};function __webpack_require__(t){var n=r[t];if(void 0!==n)return n.exports;var i=r[t]={exports:{}};return e[t](i,i.exports,__webpack_require__),i.exports}__webpack_require__.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(r,{a:r}),r},__webpack_require__.d=(e,r)=>{for(var t in r)__webpack_require__.o(r,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r);var t={};return(()=>{"use strict";__webpack_require__.d(t,{default:()=>o});class TokenError extends Error{constructor(e){super(e),this.name="TokenError"}}class InvalidSecretError extends Error{constructor(){super("Invalid secret key"),this.name="InvalidSecretError"}}const e=class SecureToken{constructor(e){this.encoder=new TextEncoder,this.decoder=new TextDecoder,this.secretKey=null,this.keyHash=null,this.initializationPromise=this.initializeKey(e)}async initializeKey(e){const r=await crypto.subtle.importKey("raw",this.encoder.encode(e),{name:"PBKDF2"},!1,["deriveBits","deriveKey"]);this.secretKey=await crypto.subtle.deriveKey({name:"PBKDF2",salt:this.encoder.encode("secure-token-salt"),iterations:1e5,hash:"SHA-256"},r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);const t=await crypto.subtle.exportKey("raw",this.secretKey),n=await crypto.subtle.digest("SHA-256",t);this.keyHash=Array.from(new Uint8Array(n)).map((e=>e.toString(16).padStart(2,"0"))).join("")}async ensureInitialized(){if(await this.initializationPromise,!this.secretKey||!this.keyHash)throw new Error("SecureToken not properly initialized")}async encrypt(e,r={}){await this.ensureInitialized();try{const t=crypto.getRandomValues(new Uint8Array(12)),n={data:e,iat:Math.floor(Date.now()/1e3),keyHash:this.keyHash};r.expiresIn&&(n.exp=n.iat+Math.floor(r.expiresIn));const i=await crypto.subtle.encrypt({name:"AES-GCM",iv:t},this.secretKey,this.encoder.encode(JSON.stringify(n))),o=new Uint8Array(t.length+new Uint8Array(i).length);return o.set(t),o.set(new Uint8Array(i),t.length),btoa(String.fromCharCode(...o))}catch(e){throw new TokenError(`Encryption failed: ${e.message}`)}}async decrypt(e){await this.ensureInitialized();try{const r=new Uint8Array(atob(e).split("").map((e=>e.charCodeAt(0)))),t=r.slice(0,12),n=r.slice(12),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:t},this.secretKey,n),o=JSON.parse(this.decoder.decode(i));if(o.keyHash!==this.keyHash)throw new InvalidSecretError;const a=Math.floor(Date.now()/1e3);if(o.exp&&a>=o.exp)throw new TokenError("Token has expired");return o.data}catch(e){if(e instanceof InvalidSecretError)throw e;if(e instanceof TokenError)throw e;throw new TokenError(`Decryption failed: ${e.message}`)}}async verify(e){try{return await this.decrypt(e),!0}catch(e){return!1}}};var r=__webpack_require__(401),n=__webpack_require__.n(r);const i=class node_SecureToken{constructor(e){this.algorithm="aes-256-gcm",this.encoding="hex",this.secretKey=n().createHash("sha256").update(String(e)).digest(),this.keyHash=n().createHash("sha256").update(this.secretKey).digest("hex")}async encrypt(e,r={}){try{const t=n().randomBytes(12),i=n().createCipheriv(this.algorithm,this.secretKey,t),o={data:e,iat:Math.floor(Date.now()/1e3),keyHash:this.keyHash};r.expiresIn&&(o.exp=o.iat+Math.floor(r.expiresIn));const a=JSON.stringify(o),s=Buffer.concat([i.update(a,"utf8"),i.final()]),c=i.getAuthTag();return Buffer.concat([t,s,c]).toString(this.encoding)}catch(e){throw new TokenError(`Encryption failed: ${e.message}`)}}async decrypt(e){try{const r=Buffer.from(e,this.encoding),t=r.subarray(0,12),i=r.subarray(r.length-16),o=r.subarray(12,r.length-16),a=n().createDecipheriv(this.algorithm,this.secretKey,t);a.setAuthTag(i);const s=Buffer.concat([a.update(o),a.final()]),c=JSON.parse(s.toString("utf8"));if(c.keyHash!==this.keyHash)throw new InvalidSecretError;const h=Math.floor(Date.now()/1e3);if(c.exp&&h>=c.exp)throw new TokenError("Token has expired");return c.data}catch(e){if(e instanceof InvalidSecretError)throw e;if(e instanceof TokenError)throw e;throw new TokenError(`Decryption failed: ${e.message}`)}}async verify(e){try{return await this.decrypt(e),!0}catch(e){return!1}}};class GTToken{constructor(r){if("undefined"!=typeof window&&window.crypto&&window.crypto.subtle)this.implementation=new e(r);else{if("undefined"==typeof process||!process.versions||!process.versions.node)throw new Error("Unsupported environment");this.implementation=new i(r)}}async encrypt(e,r={}){return this.implementation.encrypt(e,r)}async decrypt(e){return this.implementation.decrypt(e)}async verify(e){return this.implementation.verify(e)}}GTToken.TokenError=TokenError,GTToken.InvalidSecretError=InvalidSecretError;const o=GTToken})(),t=t.default})()));
//# sourceMappingURL=gt-token.js.map